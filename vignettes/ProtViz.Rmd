<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Visualisation of proteomics data using R and Bioconductor}
%\VignetteKeyword{bioinformatics, proteomics, mass spectrometry, visualisation}
-->

# Visualisation of proteomics data using R and Bioconductor
[Laurent Gatto](http://proteome.sysbiol.cam.ac.uk/lgatto/)

```{r env, message=FALSE, echo=FALSE}
library("MSnbase")
library("rpx")
library("MALDIquant")
library("MALDIquantForeign")
```

## General information

- CRAN Task View: Graphic Displays & Dynamic Graphics & Graphic
  Devices & Visualization:
  http://cran.r-project.org/web/views/Graphics.html

- ggplot2
  [book](http://link.springer.com/book/10.1007%2F978-0-387-98141-3)
  ([code](http://ggplot2.org/book/)), [web page](http://ggplot2.org/)
  and [on-line docs](http://docs.ggplot2.org/current/)
- lattice
  [book](http://lmdvr.r-forge.r-project.org/figures/figures.html) and
  [web page](http://lattice.r-forge.r-project.org/)
- *R Graphics* [book](https://www.stat.auckland.ac.nz/~paul/RG2e/)
- [R Cookbook](http://www.cookbook-r.com/Graphs/) and
  [R Graphics Cookbook](http://shop.oreilly.com/product/0636920023135.do)

## The MA plot example

The following code chunk connects to the `PXD000001` data set on the
ProteomeXchange repository and fetches the `mzTab` file. After missing
values filtering, we extract relevant data (log2 fold-changes and
log10 mean expression intensities) into `data.frames`.

```{r, makemadata, warning=FALSE, cache=TRUE}
library("rpx")
px1 <- PXDataset("PXD000001")
mztab <- pxget(px1, "PXD000001_mztab.txt")

library("MSnbase")
qnt <- readMzTabData(mztab, what = "PEP")
sampleNames(qnt) <- reporterNames(TMT6)
qnt <- filterNA(qnt)
## may be combineFeatuers

spikes <- c("P02769", "P00924", "P62894", "P00489")
protclasses <- as.character(fData(qnt)$accession)
protclasses[!protclasses %in% spikes] <- "Background"


madata42 <- data.frame(A = rowMeans(log(exprs(qnt[, c(4, 2)]), 10)),
                       M = log(exprs(qnt)[, 4], 2) - log(exprs(qnt)[, 2], 2),
                       data = rep("4vs2", nrow(qnt)),
                       protein = fData(qnt)$accession,
                       class = protclasses)

madata62 <- data.frame(A = rowMeans(log(exprs(qnt[, c(6, 2)]), 10)),
                       M = log(exprs(qnt)[, 6], 2) - log(exprs(qnt)[, 2], 2),
                       data = rep("6vs2", nrow(qnt)),
                       protein = fData(qnt)$accession,
                       class = protclasses)


madata <- rbind(madata42, madata62)
```

```{r, macols, echo=FALSE}
library("RColorBrewer")
bcols <- brewer.pal(4, "Set1")
macols <- rep("#BEBEBE", nrow(qnt))

macols[madata42$protein == "P02769"] <- bcols[1]
macols[madata42$protein == "P00924"] <- bcols[2]
macols[madata42$protein == "P62894"] <- bcols[3]
macols[madata42$protein == "P00489"] <- bcols[4]

```

### The traditional plotting system

```{r, mafig1}

par(mfrow = c(1, 2))
plot(M ~ A, data = madata42, main = "4vs2",
     xlab = "A", ylab = "M", col = madata62$class)
plot(M ~ A, data = madata62, main = "6vs2",
     xlab = "A", ylab = "M", col = madata62$class)

```

```{r mafig1pdf, ref.label='mafig1', echo=FALSE, dev='pdf', fig.width=9, fig.height=6}
```

### lattice

```{r mafig2}
library("lattice")
latma <- xyplot(M ~ A | data, data = madata,
                groups = madata$class,
                auto.key = TRUE)
print(latma)

```

```{r mafig2pdf, ref.label='mafig2', echo=FALSE, dev='pdf', fig.width=8, fig.height=6}
```

### ggplot2

```{r mafig3}

library("ggplot2")
ggma <- ggplot(aes(x = A, y = M, colour = class), data = madata,
               colour = class) +
                   geom_point() +
                       facet_grid(. ~ data)
print(ggma)

```

```{r mafig3pdf, ref.label='mafig3', echo=FALSE, dev='pdf', fig.width=8, fig.height=6}
```

### The `MAplot` method for `MSnSet` instances

```{r mafigmsnset}
MAplot(qnt, cex = .8)
```

### An interactive `shiny` app for MA plots

This app is based on Mike Love's
[shinyMA](https://github.com/mikelove/shinyMA) application, adapted
for a proteomics data. A screen shot is displayed below. To start the
application:

```{r shinyMA, eval=FALSE}
shinyMA()
```

![shinyMA screeshot](./figure/shinyMA.png)

### Preprocessing of MALDI-MS spectra

The following code chunks demonstrate the usage of the mass spectrometry
preprocessing and plotting routines in the *MALDIquant* package. *MALDIquant*
uses the traditional graphics system. Therefore *MALDIquant* overloads the
traditional functions `plot`, `lines` and `points` for its own data types. These
data types represents spectrum and peak lists as S4 classes.

After loading some example data a simple `plot` draws the raw spectrum.
```{r mqraw}
library("MALDIquant")

data("fiedler2009subset", package="MALDIquant")

plot(fiedler2009subset[[14]])
```

After some preprocessing, namely variance stabilization and smoothing, we use
`lines` to draw our baseline estimate in our processed spectrum.

```{r mqestimatebaseline}
transformedSpectra <- transformIntensity(fiedler2009subset, method = "sqrt")
smoothedSpectra <- smoothIntensity(transformedSpectra, method = "SavitzkyGolay")

plot(smoothedSpectra[[14]])
lines(estimateBaseline(smoothedSpectra[[14]]), lwd = 2, col="red")
```

After removing the background removal we could use `plot` again to draw our
baseline corrected spectrum.
```{r mqremovebaseline}
rbSpectra <- removeBaseline(smoothedSpectra)
plot(rbSpectra[[14]])
```

`detectPeaks` returns a `MassPeaks` object that offers the same traditional
graphics functions. The next code chunk demonstrates how to mark the detected
peaks in a spectrum.

```{r mqpeaks}
cbSpectra <- calibrateIntensity(rbSpectra, method = "TIC")
peaks <- detectPeaks(cbSpectra, SNR=5)

plot(cbSpectra[[14]])
points(peaks[[14]], col = "red", pch = 4, lwd = 2)
```

Additional there is a special function `labelPeaks` that allows to draw the m/z
values above the corresponding peaks. Next we mark the 5 top peaks in the
spectrum.
```{r mqlabelpeaks}
top5 <- intensity(peaks[[14]]) %in% sort(intensity(peaks[[14]]),
                                         decreasing = TRUE)[1:5]
labelPeaks(peaks[[14]], index = top5, avoidOverlap = TRUE)
```

Often multiple spectra have to be recalibrated to be comparable. Therefore
*MALDIquant* warps the spectra according to so called reference or landmark
peaks. For debugging the `determineWarpingFunctions` function offers some
warping plots. Here we show only the last 4 plots:
```{r mqwarp}
par(mfrow = c(2, 2))
reference <- referencePeaks(peaks)
warpingFunctions <- determineWarpingFunctions(peaks[13:16],
                                              reference = reference,
                                              tolerance=0.001,
                                              plot = TRUE,
                                              plotInteractive = TRUE)
par(mfrow = c(1, 1))

warpedSpectra <- warpMassSpectra(cbSpectra, warpingFunctions)
warpedPeaks <- warpMassPeaks(peaks, warpingFunctions)
```

In the next code chunk we visualise the need and the effect of the
recalibration.
```{r mqwarped}
sel <- c(2, 10, 14, 16)
xlim <- c(4180, 4240)
ylim <- c(0, 1.9e-3)
lty <- c(1, 4, 2, 6)

par(mfrow = c(1, 2))
plot(cbSpectra[[1]], xlim=xlim, ylim=ylim, type="n")

for (i in seq(along=sel)) {
  lines(peaks[[sel[i]]], lty=lty[i], col=i)
  lines(cbSpectra[[sel[i]]], lty=lty[i], col=i)
}

plot(cbSpectra[[1]], xlim=xlim, ylim=ylim, type="n")

for (i in seq(along=sel)) {
  lines(warpedPeaks[[sel[i]]], lty=lty[i], col=i)
  lines(warpedSpectra[[sel[i]]], lty=lty[i], col=i)
}
par(mfrow = c(1, 1))
```
